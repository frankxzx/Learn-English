<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Template Grind - English Muscle Builder</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-a: #fff8e8;
      --bg-b: #ffe4bf;
      --ink: #1a1d29;
      --muted: #5a6278;
      --hot: #ff6a3d;
      --accent: #0da9a0;
      --card: #fffdf8;
      --success: #1f9d55;
      --warn: #d9480f;
      --shadow: 0 18px 45px rgba(26, 29, 41, 0.16);
      --ring: 0 0 0 3px rgba(13, 169, 160, 0.25);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Space Grotesk", "Avenir Next", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 8% 18%, rgba(255, 106, 61, 0.18) 0, transparent 30%),
        radial-gradient(circle at 92% 22%, rgba(13, 169, 160, 0.2) 0, transparent 36%),
        linear-gradient(130deg, var(--bg-a), var(--bg-b));
      display: flex;
      justify-content: center;
      padding: 26px 16px 40px;
    }

    .app {
      width: min(980px, 100%);
      display: grid;
      gap: 14px;
    }

    .top {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 14px;
      align-items: center;
    }

    .title h1 {
      margin: 0;
      font-size: clamp(1.35rem, 2.2vw, 2rem);
      letter-spacing: 0.01em;
    }

    .title p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .stats {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      background: #fff;
      border: 2px solid rgba(26, 29, 41, 0.08);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 0.83rem;
      font-weight: 600;
      box-shadow: 0 5px 16px rgba(26, 29, 41, 0.08);
      white-space: nowrap;
    }

    .pill strong {
      color: var(--hot);
      margin-left: 6px;
      font-size: 0.95rem;
    }

    .progress-wrap {
      background: rgba(255, 255, 255, 0.86);
      border-radius: 14px;
      border: 2px solid rgba(26, 29, 41, 0.09);
      padding: 10px;
      box-shadow: var(--shadow);
    }

    .progress-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 0.9rem;
      font-weight: 600;
    }

    .bar {
      height: 12px;
      border-radius: 999px;
      background: rgba(26, 29, 41, 0.1);
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      width: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), #17cfa2);
      transition: width 0.25s ease;
    }

    .card {
      border-radius: 24px;
      background: var(--card);
      border: 3px solid rgba(26, 29, 41, 0.09);
      box-shadow: var(--shadow);
      padding: clamp(18px, 4vw, 38px);
      position: relative;
      overflow: hidden;
    }

    .card::after {
      content: "";
      position: absolute;
      width: 230px;
      height: 230px;
      background: radial-gradient(circle, rgba(255, 106, 61, 0.14), transparent 65%);
      top: -95px;
      right: -90px;
      pointer-events: none;
    }

    .tagline {
      display: inline-block;
      border: 2px solid rgba(26, 29, 41, 0.15);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.73rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      font-weight: 700;
      background: #fff;
      position: relative;
      z-index: 1;
    }

    .template {
      margin: 14px 0 14px;
      font-size: clamp(1.2rem, 3vw, 2.2rem);
      font-weight: 700;
      line-height: 1.35;
      letter-spacing: 0.01em;
      position: relative;
      z-index: 1;
      min-height: 86px;
    }

    .template mark {
      background: linear-gradient(transparent 40%, rgba(255, 106, 61, 0.3) 40%);
      color: inherit;
      padding: 0 1px;
      font-family: "IBM Plex Mono", monospace;
    }

    .example {
      margin: 0;
      font-size: 1rem;
      color: #2b3040;
      background: rgba(13, 169, 160, 0.08);
      border-radius: 12px;
      padding: 12px;
      border: 1px dashed rgba(13, 169, 160, 0.45);
      position: relative;
      z-index: 1;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .audio-controls {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
    }

    button {
      border: 0;
      border-radius: 14px;
      padding: 14px 12px;
      font-family: inherit;
      font-weight: 700;
      font-size: 0.95rem;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.15s ease;
    }

    button:focus-visible {
      outline: none;
      box-shadow: var(--ring);
    }

    button:active {
      transform: translateY(1px) scale(0.995);
    }

    .again {
      background: #fff;
      border: 2px solid rgba(26, 29, 41, 0.17);
      color: var(--ink);
    }

    .good {
      background: #d9f5ea;
      border: 2px solid rgba(31, 157, 85, 0.25);
      color: #125c34;
    }

    .mastered {
      background: #ffe2d7;
      border: 2px solid rgba(217, 72, 15, 0.24);
      color: #912f0f;
    }

    .speak {
      background: #e8f5ff;
      border: 2px solid rgba(13, 117, 169, 0.25);
      color: #0d4c75;
    }

    .stop {
      background: #fff;
      border: 2px solid rgba(26, 29, 41, 0.17);
      color: var(--ink);
    }

    .toggle {
      background: #fff;
      border: 2px solid rgba(26, 29, 41, 0.17);
      color: var(--ink);
    }

    .toggle.active {
      background: #d9f5ea;
      border-color: rgba(31, 157, 85, 0.35);
      color: #125c34;
    }

    .hint {
      font-size: 0.84rem;
      color: var(--muted);
      font-family: "IBM Plex Mono", monospace;
      text-align: center;
    }

    .feed {
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.86);
      border: 2px solid rgba(26, 29, 41, 0.08);
      padding: 12px;
      box-shadow: 0 8px 24px rgba(26, 29, 41, 0.08);
      max-height: 170px;
      overflow: auto;
    }

    .feed h2 {
      margin: 0 0 10px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .feed ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }

    .feed li {
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 0.9rem;
      background: #fff;
      border: 1px solid rgba(26, 29, 41, 0.1);
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .score-up {
      color: var(--success);
      font-weight: 700;
    }

    .finish {
      display: none;
      text-align: center;
      padding: 30px 14px;
      border-radius: 24px;
      background: #fff;
      border: 3px solid rgba(31, 157, 85, 0.3);
      box-shadow: var(--shadow);
      animation: pop 0.35s ease;
    }

    .finish h2 {
      margin: 0;
      font-size: clamp(1.3rem, 2.5vw, 1.8rem);
    }

    .finish p {
      margin: 8px 0 0;
      color: var(--muted);
    }

    .finish strong {
      color: var(--hot);
    }

    .show {
      display: block;
    }

    @keyframes pop {
      from {
        opacity: 0;
        transform: translateY(4px) scale(0.98);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @media (max-width: 700px) {
      .top {
        grid-template-columns: 1fr;
      }

      .stats {
        justify-content: flex-start;
      }

      .controls {
        grid-template-columns: 1fr;
      }

      .audio-controls {
        grid-template-columns: 1fr;
      }

      .template {
        min-height: 128px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="top">
      <div class="title">
        <h1>Template Grind</h1>
        <p>刷卡 20 张，专注“工作英文表达”肌肉记忆</p>
      </div>
      <div class="stats">
        <div class="pill">Score<strong id="score">0</strong></div>
        <div class="pill">Today<strong id="todayCount">0</strong></div>
        <div class="pill">Due<strong id="dueCount">0</strong></div>
        <div class="pill">Mastery<strong id="masteryRate">0%</strong></div>
        <div class="pill">Left<strong id="left">20</strong></div>
      </div>
    </section>

    <section class="progress-wrap" aria-label="training progress">
      <div class="progress-head">
        <span>Round Progress</span>
        <span id="percent">0%</span>
      </div>
      <div class="bar"><div class="bar-fill" id="barFill"></div></div>
    </section>

    <section class="card" id="card" aria-live="polite">
      <span class="tagline" id="tag">Daily</span>
      <p class="template" id="template"></p>
      <p class="example" id="example"></p>
    </section>

    <section class="controls">
      <button class="again" id="againBtn">Again (A) +1</button>
      <button class="good" id="goodBtn">Good (S) +3</button>
      <button class="mastered" id="masteredBtn">Mastered (D) +5</button>
    </section>

    <section class="audio-controls">
      <button class="speak" id="speakTplBtn">Play Template (P)</button>
      <button class="speak" id="speakBothBtn">Play Both (O)</button>
      <button class="stop" id="stopSpeakBtn">Stop (K)</button>
      <button class="toggle" id="autoSpeakBtn">Auto Speak: Off</button>
      <button class="toggle" id="slowSpeakBtn">Slow: Off</button>
    </section>

    <p class="hint">快捷键: <strong>A</strong> 再看一次, <strong>S</strong> 记住了, <strong>D</strong> 已掌握, <strong>R</strong> 重开一轮, <strong>P</strong> 读模板, <strong>O</strong> 读整卡, <strong>K</strong> 停止</p>

    <section class="feed" aria-label="recent activity">
      <h2>Session Feed</h2>
      <ul id="feedList"></ul>
    </section>

    <section class="feed" aria-label="memory report">
      <h2>Memory Report</h2>
      <ul id="reportList"></ul>
    </section>

    <section class="finish" id="finish">
      <h2>Round Complete</h2>
      <p>你刷完了 <strong id="finalCount">0</strong> 张卡。最终分数: <strong id="finalScore">0</strong></p>
      <p>按 <strong>R</strong> 开始下一轮，维持连击。</p>
    </section>
  </main>

  <script>
    const STORAGE_KEY = "template-grind-srs-v1";
    const DAILY_LIMIT = 20;
    const MIN_EASE = 1.3;
    const DAY_MS = 24 * 60 * 60 * 1000;

    const templateSeed = [
      { tag: "Daily", tpl: "I finished <mark>X</mark>. I’m working on <mark>Y</mark>. I’m blocked by <mark>Z</mark>.", ex: "I finished auth bug fixes. I’m working on checkout retries. I’m blocked by timeout logs." },
      { tag: "Daily", tpl: "The current status is <mark>X</mark>, and next I’ll do <mark>Y</mark>.", ex: "The current status is stable, and next I’ll add load tests." },
      { tag: "Blocker", tpl: "I’m blocked by <mark>X</mark>. Could you help with <mark>Y</mark>?", ex: "I’m blocked by staging access. Could you help with permission setup?" },
      { tag: "Blocker", tpl: "If <mark>X</mark> is solved today, I can deliver by <mark>Y</mark>.", ex: "If API contract is solved today, I can deliver by tomorrow." },
      { tag: "Clarify", tpl: "Could you clarify the acceptance criteria for <mark>X</mark>?", ex: "Could you clarify the acceptance criteria for refund workflow?" },
      { tag: "Clarify", tpl: "Just to confirm, do we want <mark>A</mark> or <mark>B</mark>?", ex: "Just to confirm, do we want strict validation or soft validation?" },
      { tag: "Design", tpl: "Option A is <mark>X</mark>, while Option B is <mark>Y</mark>.", ex: "Option A is faster to ship, while Option B is easier to maintain." },
      { tag: "Design", tpl: "I recommend <mark>X</mark> for now, and we can revisit <mark>Y</mark> later.", ex: "I recommend a cache patch for now, and we can revisit architecture later." },
      { tag: "Review", tpl: "This PR focuses on <mark>X</mark> and intentionally leaves <mark>Y</mark> for follow-up.", ex: "This PR focuses on retry logic and intentionally leaves UI polish for follow-up." },
      { tag: "Review", tpl: "I addressed all comments and added tests for <mark>X</mark>.", ex: "I addressed all comments and added tests for timeout handling." },
      { tag: "Disagree", tpl: "I see your point. My concern is <mark>X</mark> because <mark>Y</mark>.", ex: "I see your point. My concern is rollback risk because traffic is peaking." },
      { tag: "Disagree", tpl: "Could we try <mark>X</mark> first before moving to <mark>Y</mark>?", ex: "Could we try partial rollout first before moving to full migration?" },
      { tag: "Risk", tpl: "The main risk is <mark>X</mark>, which may impact <mark>Y</mark>.", ex: "The main risk is memory pressure, which may impact API latency." },
      { tag: "Risk", tpl: "We should prepare a rollback plan before <mark>X</mark>.", ex: "We should prepare a rollback plan before tonight’s release." },
      { tag: "Priority", tpl: "Given current scope, this is likely a <mark>X</mark>-day task.", ex: "Given current scope, this is likely a two-day task." },
      { tag: "Priority", tpl: "We can hit the deadline if we reduce <mark>X</mark>.", ex: "We can hit the deadline if we reduce non-critical UI changes." },
      { tag: "Cross-team", tpl: "We need input from <mark>X</mark> to finalize <mark>Y</mark>.", ex: "We need input from infra team to finalize deployment windows." },
      { tag: "Cross-team", tpl: "Please confirm <mark>X</mark> by <mark>Y</mark> so we can proceed.", ex: "Please confirm API fields by EOD so we can proceed." },
      { tag: "Incident", tpl: "We detected an issue affecting <mark>X</mark> since <mark>Y</mark>.", ex: "We detected an issue affecting payment users since 10:30 AM." },
      { tag: "Incident", tpl: "A temporary mitigation is in place, and we’re monitoring <mark>X</mark>.", ex: "A temporary mitigation is in place, and we’re monitoring error rate." }
    ];

    const templates = templateSeed.map((item, idx) => ({
      ...item,
      id: `tpl-${String(idx + 1).padStart(2, "0")}`
    }));

    const scoreEl = document.getElementById("score");
    const todayCountEl = document.getElementById("todayCount");
    const dueCountEl = document.getElementById("dueCount");
    const masteryRateEl = document.getElementById("masteryRate");
    const leftEl = document.getElementById("left");
    const percentEl = document.getElementById("percent");
    const barFill = document.getElementById("barFill");
    const tagEl = document.getElementById("tag");
    const templateEl = document.getElementById("template");
    const exampleEl = document.getElementById("example");
    const feedList = document.getElementById("feedList");
    const reportList = document.getElementById("reportList");
    const finish = document.getElementById("finish");
    const finalScoreEl = document.getElementById("finalScore");
    const finalCountEl = document.getElementById("finalCount");

    const againBtn = document.getElementById("againBtn");
    const goodBtn = document.getElementById("goodBtn");
    const masteredBtn = document.getElementById("masteredBtn");
    const speakTplBtn = document.getElementById("speakTplBtn");
    const speakBothBtn = document.getElementById("speakBothBtn");
    const stopSpeakBtn = document.getElementById("stopSpeakBtn");
    const autoSpeakBtn = document.getElementById("autoSpeakBtn");
    const slowSpeakBtn = document.getElementById("slowSpeakBtn");

    let deck = [];
    let current = 0;
    let score = 0;
    let autoSpeak = false;
    let slowSpeak = false;
    let selectedVoice = null;
    let progress = null;

    function dayKey(date = new Date()) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    function addDays(baseKey, days) {
      const base = new Date(`${baseKey}T00:00:00`);
      base.setTime(base.getTime() + days * DAY_MS);
      return dayKey(base);
    }

    function defaultCardState() {
      return {
        repetitions: 0,
        interval: 0,
        ease: 2.5,
        lapses: 0,
        total: 0,
        success: 0,
        due: dayKey(),
        lastSeen: null,
        history: []
      };
    }

    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        const parsed = raw ? JSON.parse(raw) : {};
        const cards = parsed.cards && typeof parsed.cards === "object" ? parsed.cards : {};
        return { cards };
      } catch (_) {
        return { cards: {} };
      }
    }

    function saveProgress() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
    }

    function ensureCardState(cardId) {
      if (!progress.cards[cardId]) {
        progress.cards[cardId] = defaultCardState();
      }
      return progress.cards[cardId];
    }

    function stripHtml(html) {
      const holder = document.createElement("div");
      holder.innerHTML = html;
      return holder.textContent || "";
    }

    function pickVoice() {
      if (!("speechSynthesis" in window)) {
        return null;
      }
      const voices = window.speechSynthesis.getVoices();
      if (!voices.length) {
        return null;
      }
      const enVoice = voices.find((v) => v.lang && v.lang.toLowerCase().startsWith("en"));
      return enVoice || voices[0];
    }

    function speakText(text, onEnd) {
      if (!("speechSynthesis" in window)) {
        pushFeed("Speech not supported in this browser", 0);
        return;
      }
      const utterance = new SpeechSynthesisUtterance(text);
      selectedVoice = selectedVoice || pickVoice();
      if (selectedVoice) {
        utterance.voice = selectedVoice;
        utterance.lang = selectedVoice.lang;
      } else {
        utterance.lang = "en-US";
      }
      utterance.rate = slowSpeak ? 0.82 : 1.0;
      utterance.pitch = 1;
      if (typeof onEnd === "function") {
        utterance.onend = onEnd;
      }
      window.speechSynthesis.speak(utterance);
    }

    function stopSpeaking() {
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
    }

    function speakTemplateOnly() {
      if (current >= deck.length) {
        return;
      }
      stopSpeaking();
      const item = deck[current];
      speakText(stripHtml(item.tpl));
    }

    function speakCard() {
      if (current >= deck.length) {
        return;
      }
      stopSpeaking();
      const item = deck[current];
      speakText(stripHtml(item.tpl), () => {
        speakText(item.ex);
      });
    }

    function renderSpeakToggles() {
      autoSpeakBtn.classList.toggle("active", autoSpeak);
      slowSpeakBtn.classList.toggle("active", slowSpeak);
      autoSpeakBtn.textContent = `Auto Speak: ${autoSpeak ? "On" : "Off"}`;
      slowSpeakBtn.textContent = `Slow: ${slowSpeak ? "On" : "Off"}`;
    }

    function shuffle(list) {
      const arr = [...list];
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function pushFeed(text, points) {
      const li = document.createElement("li");
      li.innerHTML = `<span>${text}</span><span class="score-up">+${points}</span>`;
      feedList.prepend(li);
      while (feedList.children.length > 7) {
        feedList.removeChild(feedList.lastChild);
      }
    }

    function cardMastery(state) {
      if (!state.total) {
        return 0;
      }
      const accuracy = state.success / state.total;
      const stability = Math.min(1, state.interval / 21);
      const lapsePenalty = Math.min(0.35, state.lapses * 0.05);
      const raw = 0.55 * accuracy + 0.45 * stability - lapsePenalty;
      return Math.max(0, Math.min(1, raw));
    }

    function updateReport() {
      const today = dayKey();
      const states = templates.map((card) => ({ card, state: ensureCardState(card.id) }));
      const learned = states.filter(({ state }) => state.total > 0);
      const studiedToday = states.filter(({ state }) => state.lastSeen === today).length;
      const dueCount = states.filter(({ state }) => state.due <= today && state.lastSeen !== today).length;
      const mastery = learned.length
        ? Math.round((learned.reduce((sum, item) => sum + cardMastery(item.state), 0) / learned.length) * 100)
        : 0;

      const weakest = learned
        .map(({ card, state }) => ({
          card,
          score: Math.round(cardMastery(state) * 100),
          due: state.due,
          lapses: state.lapses
        }))
        .sort((a, b) => a.score - b.score || b.lapses - a.lapses)
        .slice(0, 3);

      todayCountEl.textContent = String(studiedToday);
      dueCountEl.textContent = String(dueCount);
      masteryRateEl.textContent = `${mastery}%`;

      reportList.innerHTML = "";

      const summary = [
        `Learned cards: ${learned.length}/${templates.length}`,
        `Due today (not seen yet): ${dueCount}`,
        `Average mastery: ${mastery}%`
      ];
      summary.forEach((line) => {
        const li = document.createElement("li");
        li.innerHTML = `<span>${line}</span><span>${today}</span>`;
        reportList.appendChild(li);
      });

      if (!weakest.length) {
        const li = document.createElement("li");
        li.innerHTML = "<span>Weak focus: no weak cards yet. Keep building reps.</span><span>-</span>";
        reportList.appendChild(li);
        return;
      }

      weakest.forEach((item) => {
        const li = document.createElement("li");
        li.innerHTML = `<span>Weak focus: [${item.card.tag}] ${stripHtml(item.card.tpl)}</span><span>${item.score}% · due ${item.due}</span>`;
        reportList.appendChild(li);
      });
    }

    function buildDeck() {
      const today = dayKey();
      const available = templates.filter((card) => ensureCardState(card.id).lastSeen !== today);
      const due = available
        .filter((card) => ensureCardState(card.id).due <= today)
        .sort((a, b) => {
          const sa = ensureCardState(a.id);
          const sb = ensureCardState(b.id);
          if (sa.due !== sb.due) {
            return sa.due.localeCompare(sb.due);
          }
          return cardMastery(sa) - cardMastery(sb);
        });
      const fresh = shuffle(available.filter((card) => ensureCardState(card.id).total === 0));
      const future = shuffle(available.filter((card) => ensureCardState(card.id).due > today));
      const picked = [];
      const used = new Set();

      [due, fresh, future].forEach((bucket) => {
        bucket.forEach((card) => {
          if (picked.length >= DAILY_LIMIT || used.has(card.id)) {
            return;
          }
          used.add(card.id);
          picked.push(card);
        });
      });

      return picked;
    }

    function updateProgress() {
      const done = current;
      const total = deck.length;
      const percent = total ? Math.round((done / total) * 100) : 100;
      leftEl.textContent = String(Math.max(0, total - done));
      percentEl.textContent = `${percent}%`;
      barFill.style.width = `${percent}%`;
      scoreEl.textContent = String(score);
      updateReport();
    }

    function renderCard() {
      if (!deck.length) {
        stopSpeaking();
        finish.classList.add("show");
        finalCountEl.textContent = "0";
        finalScoreEl.textContent = "0";
        tagEl.textContent = "Done";
        templateEl.innerHTML = "Today queue is empty. Come back tomorrow for new due cards.";
        exampleEl.textContent = "Tip: 按 R 刷新。系统会追踪你的间隔复习。";
        updateProgress();
        return;
      }

      if (current >= deck.length) {
        stopSpeaking();
        updateProgress();
        finalCountEl.textContent = String(deck.length);
        finalScoreEl.textContent = String(score);
        finish.classList.add("show");
        return;
      }

      finish.classList.remove("show");
      const item = deck[current];
      tagEl.textContent = item.tag;
      templateEl.innerHTML = item.tpl;
      exampleEl.textContent = `Example: ${item.ex}`;
      updateProgress();
      if (autoSpeak) {
        speakCard();
      }
    }

    function applySrs(cardId, rating) {
      const state = ensureCardState(cardId);
      const today = dayKey();
      state.total += 1;
      state.lastSeen = today;

      if (rating === "again") {
        state.repetitions = 0;
        state.interval = 1;
        state.ease = Math.max(MIN_EASE, state.ease - 0.2);
        state.lapses += 1;
      } else if (rating === "good") {
        state.repetitions += 1;
        state.success += 1;
        if (state.repetitions === 1) {
          state.interval = 1;
        } else if (state.repetitions === 2) {
          state.interval = 3;
        } else {
          state.interval = Math.max(2, Math.round(state.interval * state.ease));
        }
      } else if (rating === "mastered") {
        state.repetitions += 1;
        state.success += 1;
        if (state.repetitions === 1) {
          state.interval = 2;
        } else if (state.repetitions === 2) {
          state.interval = 5;
        } else {
          state.interval = Math.max(3, Math.round(state.interval * state.ease * 1.25));
        }
        state.ease = Math.min(3.2, state.ease + 0.05);
      }

      state.due = addDays(today, state.interval || 1);
      state.history.push({
        date: today,
        rating,
        interval: state.interval,
        ease: Number(state.ease.toFixed(2))
      });
      if (state.history.length > 30) {
        state.history = state.history.slice(-30);
      }

      saveProgress();
      return state;
    }

    function rateCard(points, note, rating) {
      if (current >= deck.length) {
        return;
      }
      const item = deck[current];
      const state = applySrs(item.id, rating);
      score += points;
      pushFeed(`${item.tag}: ${note} -> due ${state.due}`, points);
      current += 1;
      renderCard();
    }

    function resetRound() {
      stopSpeaking();
      deck = buildDeck();
      current = 0;
      score = 0;
      feedList.innerHTML = "";
      if (deck.length) {
        pushFeed(`New round started: ${deck.length} cards`, 0);
      } else {
        pushFeed("No cards due right now", 0);
      }
      renderCard();
    }

    againBtn.addEventListener("click", () => rateCard(1, "Again", "again"));
    goodBtn.addEventListener("click", () => rateCard(3, "Good", "good"));
    masteredBtn.addEventListener("click", () => rateCard(5, "Mastered", "mastered"));
    speakTplBtn.addEventListener("click", speakTemplateOnly);
    speakBothBtn.addEventListener("click", speakCard);
    stopSpeakBtn.addEventListener("click", stopSpeaking);
    autoSpeakBtn.addEventListener("click", () => {
      autoSpeak = !autoSpeak;
      renderSpeakToggles();
      if (autoSpeak) {
        speakCard();
      }
    });
    slowSpeakBtn.addEventListener("click", () => {
      slowSpeak = !slowSpeak;
      renderSpeakToggles();
      pushFeed(`Slow mode ${slowSpeak ? "enabled" : "disabled"}`, 0);
    });

    if ("speechSynthesis" in window) {
      selectedVoice = pickVoice();
      window.speechSynthesis.onvoiceschanged = () => {
        selectedVoice = pickVoice();
      };
    }

    window.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      if (key === "a") {
        rateCard(1, "Again", "again");
      }
      if (key === "s") {
        rateCard(3, "Good", "good");
      }
      if (key === "d") {
        rateCard(5, "Mastered", "mastered");
      }
      if (key === "r") {
        resetRound();
      }
      if (key === "p") {
        speakTemplateOnly();
      }
      if (key === "o") {
        speakCard();
      }
      if (key === "k") {
        stopSpeaking();
      }
    });

    progress = loadProgress();
    templates.forEach((card) => ensureCardState(card.id));
    saveProgress();
    renderSpeakToggles();
    resetRound();
  </script>
</body>
</html>
